diff --git src/wp-admin/admin.php src/wp-admin/admin.php
index 8f0e761255..74fe4f1950 100644
--- src/wp-admin/admin.php
+++ src/wp-admin/admin.php
@@ -121,8 +121,9 @@ wp_enqueue_script( 'common' );
  * @global string $plugin_page
  * @global string $typenow
  * @global string $taxnow
+ * @global string $feedback_type
  */
-global $pagenow, $wp_importers, $hook_suffix, $plugin_page, $typenow, $taxnow;
+global $pagenow, $wp_importers, $hook_suffix, $plugin_page, $typenow, $taxnow, $feedback_type;
 
 $page_hook = null;
 
@@ -145,6 +146,12 @@ if ( isset( $_REQUEST['taxonomy'] ) && taxonomy_exists( $_REQUEST['taxonomy'] )
 	$taxnow = '';
 }
 
+if ( isset( $_REQUEST['feedback_type'] ) && feedback_type_exists( $_REQUEST['feedback_type'] ) ) {
+	$feedback_type = $_REQUEST['feedback_type'];
+} else {
+	$feedback_type = '';
+}
+
 if ( WP_NETWORK_ADMIN ) {
 	require ABSPATH . 'wp-admin/network/menu.php';
 } elseif ( WP_USER_ADMIN ) {
@@ -172,6 +179,8 @@ do_action( 'admin_init' );
 if ( isset( $plugin_page ) ) {
 	if ( ! empty( $typenow ) ) {
 		$the_parent = $pagenow . '?post_type=' . $typenow;
+	} elseif ( ! empty( $feedback_type ) ) {
+		$the_parent = $pagenow . '?feedback_type=' . $feedback_type;
 	} else {
 		$the_parent = $pagenow;
 	}
diff --git src/wp-admin/css/feedbacks.css src/wp-admin/css/feedbacks.css
new file mode 100644
index 0000000000..6258b264b8
--- /dev/null
+++ src/wp-admin/css/feedbacks.css
@@ -0,0 +1,92 @@
+body.edit-feedbacks-php #wpcontent,
+body.edit-feedbacks-php.auto-fold #wpcontent {
+	padding-left: 0;
+}
+
+body.edit-feedbacks-php.auto-fold #wpcontent .wrap {
+	padding-left: 20px;
+}
+
+/* Emulates .wrap h1 styling */
+.feedbacks-header h1 {
+	display: inline-block;
+	font-weight: 400;
+	margin: 0 20px 16px;
+	font-size: 23px;
+	padding: 9px 0 4px 0;
+	line-height: 1.3;
+}
+
+.feedbacks-header {
+	margin: 0 0 1rem;
+	background: #fff;
+	border-bottom: 1px solid #e2e4e7;
+}
+
+.feedbacks-tabs-wrapper ul {
+	margin: 0;
+}
+
+.feedbacks-tabs-wrapper ul > li {
+	vertical-align: top;
+	display: inline-block;
+	margin: 0 0 0 4px;
+}
+
+.feedbacks-tab {
+	display: block;
+	text-decoration: none;
+	color: inherit;
+	padding: 0.5rem 1rem 1rem;
+	margin: 0 1rem;
+	transition: box-shadow 0.5s ease-in-out;
+}
+
+.feedbacks-tab:focus {
+	color: #191e23;
+	outline: 1px solid #6c7781;
+	box-shadow: none;
+}
+
+.feedbacks-tab.active {
+	box-shadow: inset 0 -3px #007cba;
+	font-weight: 600;
+}
+
+a.feedbacks-tab .awaiting-mod {
+	display: inline-block;
+	vertical-align: top;
+	box-sizing: border-box;
+	margin: 1px 0 -1px 2px;
+	padding: 0 5px;
+	min-width: 18px;
+	height: 18px;
+	border-radius: 9px;
+	background-color: #ca4a1f;
+	color: #fff;
+	font-size: 11px;
+	line-height: 1.6;
+	text-align: center;
+	z-index: 26;
+}
+
+/* Better position for the WordPress admin notices and update nag. */
+body.edit-feedbacks-php .notice {
+	margin: 5px 20px 15px 22px;
+}
+
+body.edit-feedbacks-php .update-nag {
+	margin-bottom: 20px;
+	margin-left: 22px;
+}
+
+@media screen and (max-width: 782px) {
+	body.edit-feedbacks-php .notice {
+		margin: 5px 10px 15px;
+	}
+
+	body.edit-feedbacks-php .update-nag {
+		margin-right: 10px;
+		margin-left: 10px;
+	}
+}
diff --git src/wp-admin/edit-feedbacks.php src/wp-admin/edit-feedbacks.php
new file mode 100644
index 0000000000..e33e53d6c1
--- /dev/null
+++ src/wp-admin/edit-feedbacks.php
@@ -0,0 +1,127 @@
+<?php
+/**
+ * Edit Feedbacks Administration Screen.
+ *
+ * @package WordPress
+ * @subpackage Administration
+ * @since 5.4.0
+ */
+
+/** WordPress Administration Bootstrap */
+require_once dirname( __FILE__ ) . '/admin.php';
+
+if ( ! $feedback_type ) {
+	wp_die( __( 'Invalid feedback type.' ) );
+}
+
+$feedback_types = get_feedback_types( array( 'show_ui' => true ), false );
+$type_names     = wp_list_pluck( $feedback_types, 'name' );
+
+if ( ! in_array( $feedback_type, $type_names, true ) ) {
+	wp_die( __( 'Sorry, you are not allowed to edit posts in this post type.' ) );
+}
+
+// Get the types' counts.
+$feedback_types_count = wp_count_feedbacks( $type_names );
+
+// Get the feedback's type list table.
+$wp_list_table = _get_list_table(
+	'WP_Feedbacks_List_Table',
+	array(
+		'plural'   => $feedback_types[ $feedback_type ]->plural,
+		'singular' => $feedback_types[ $feedback_type ]->singular,
+	)
+);
+
+$pagenum  = $wp_list_table->get_pagenum();
+$doaction = $wp_list_table->current_action();
+
+if ( $doaction ) {
+	die();
+}
+
+// Generic title for all feedbacks.
+$title = __( 'Feedbacks' );
+
+$wp_list_table->prepare_items();
+
+wp_enqueue_style( 'feedbacks' );
+wp_enqueue_script( 'admin-comments' );
+enqueue_comment_hotkeys_js();
+
+add_screen_option( 'per_page' );
+
+require_once ABSPATH . 'wp-admin/admin-header.php';
+?>
+<div class="feedbacks-header">
+	<div class="feedbacks-title-section">
+		<h1>
+			<?php echo esc_html( $title ); ?>
+		</h1>
+	</div>
+
+	<nav class="feedbacks-tabs-wrapper" aria-label="<?php esc_attr_e( 'Secondary menu' ); ?>">
+		<ul>
+			<?php foreach ( $feedback_types as $type ) : ?>
+				<li>
+					<a href="<?php echo esc_url( add_query_arg( 'feedback_type', $type->name, admin_url( 'edit-feedbacks.php' ) ) ); ?>" class="feedbacks-tab<?php echo $feedback_type === $type->name ? ' active' : ''; ?>" aria-current="<?php echo $feedback_type === $type->name ? 'true' : 'false'; ?>">
+						<?php
+						$feedback_bubble = '';
+						if ( isset( $feedback_types_count[ $type->name ]->moderated ) && $feedback_types_count[ $type->name ]->moderated ) {
+							$awaiting_mod  = $feedback_types_count[ $type->name ]->moderated;
+							$awaiting_text = sprintf(
+								_n( $type->labels->awaiting_mod_item, $type->labels->awaiting_mod_items, $awaiting_mod ),
+								number_format_i18n( $awaiting_mod )
+							);
+
+							$feedback_bubble  = ' <span class="fn-label awaiting-mod pending-count count-' . $awaiting_mod . '" aria-hidden="true">' . number_format_i18n( $awaiting_mod ) . '</span>';
+							$feedback_bubble .= '<span class="screen-reader-text comments-in-moderation-text">' . $awaiting_text . '</span>';
+						}
+
+						/* translators: Tab heading for Comment Feedback type. */
+						printf( '%1$s%2$s', esc_html( $type->labels->name_admin_nav ), $feedback_bubble );
+						?>
+					</a>
+				</li>
+			<?php endforeach; ?>
+		</ul>
+	</nav>
+</div>
+
+<?php
+if ( isset( $_REQUEST['s'] ) && strlen( $_REQUEST['s'] ) ) {
+	echo '<span class="subtitle">';
+	printf(
+		/* translators: %s: Search query. */
+		__( 'Search results for &#8220;%s&#8221;' ),
+		wp_html_excerpt( esc_html( wp_unslash( $_REQUEST['s'] ) ), 50, '&hellip;' )
+	);
+	echo '</span>';
+}
+?>
+
+<hr class="wp-header-end">
+
+<div class="wrap">
+
+	<?php $wp_list_table->views(); ?>
+
+	<form id="comments-form" method="get">
+		<?php $wp_list_table->search_box( __( 'Search Comments' ), 'comment' ); ?>
+		<input type="hidden" name="pagegen_timestamp" value="<?php echo esc_attr( current_time( 'mysql', 1 ) ); ?>" />
+
+		<input type="hidden" name="_total" value="<?php echo esc_attr( $wp_list_table->get_pagination_arg( 'total_items' ) ); ?>" />
+		<input type="hidden" name="_per_page" value="<?php echo esc_attr( $wp_list_table->get_pagination_arg( 'per_page' ) ); ?>" />
+		<input type="hidden" name="_page" value="<?php echo esc_attr( $wp_list_table->get_pagination_arg( 'page' ) ); ?>" />
+
+		<?php if ( isset( $_REQUEST['paged'] ) ) { ?>
+			<input type="hidden" name="paged" value="<?php echo esc_attr( absint( $_REQUEST['paged'] ) ); ?>" />
+		<?php } ?>
+
+		<?php $wp_list_table->display(); ?>
+	</form>
+
+</div>
+
+<?php
+include ABSPATH . 'wp-admin/admin-footer.php';
diff --git src/wp-admin/includes/class-wp-feedbacks-list-table.php src/wp-admin/includes/class-wp-feedbacks-list-table.php
new file mode 100644
index 0000000000..e9f34df737
--- /dev/null
+++ src/wp-admin/includes/class-wp-feedbacks-list-table.php
@@ -0,0 +1,970 @@
+<?php
+/**
+ * List Table API: WP_Feedbacks_List_Table class
+ *
+ * @package WordPress
+ * @subpackage Administration
+ * @since 5.4.0
+ */
+
+/**
+ * Core class used to implement displaying feedbacks in a list table.
+ *
+ * @since 5.4.0
+ * @access private
+ *
+ * @see WP_List_Table
+ */
+class WP_Feedbacks_List_Table extends WP_List_Table {
+	/**
+	 * Feedback type key.
+	 *
+	 * @since 5.4.0
+	 * @var string $type
+	 */
+	public $type;
+
+	public $checkbox = true;
+
+	/**
+	 * Number of comments per type and stati.
+	 *
+	 * @since 5.4.0
+	 * @var object $type
+	 */
+	public $num_comments = null;
+
+	public $pending_count = array();
+
+	public $extra_items;
+
+	private $user_can;
+
+	/**
+	 * Constructor.
+	 *
+	 * @since 3.1.0
+	 *
+	 * @see WP_List_Table::__construct() for more information on default arguments.
+	 *
+	 * @global int $post_id
+	 *
+	 * @param array $args An associative array of arguments.
+	 */
+	public function __construct( $args = array() ) {
+		global $post_id;
+
+		$post_id = 0;
+		if ( isset( $_REQUEST['p'] ) ) {
+			$post_id = absint( $_REQUEST['p'] );
+		}
+
+		$args = wp_parse_args(
+			$args,
+			array(
+				'plural'   => 'comments',
+				'singular' => 'comment',
+				'ajax'     => true,
+				'screen'   => null,
+			)
+		);
+
+		parent::__construct( $args );
+
+		$this->type = $this->screen->feedback_type;
+		if ( 'comment' === $this->type && get_option( 'show_avatars' ) ) {
+			add_filter( 'comment_author', array( $this, 'floated_admin_avatar' ), 10, 2 );
+		}
+	}
+
+	public function floated_admin_avatar( $name, $comment_ID ) {
+		$comment = get_comment( $comment_ID );
+		$avatar  = get_avatar( $comment, 32, 'mystery' );
+		return "$avatar $name";
+	}
+
+	/**
+	 * @return bool
+	 */
+	public function ajax_user_can() {
+		return current_user_can( 'edit_posts' );
+	}
+
+	/**
+	 * @global int    $post_id
+	 * @global string $comment_status
+	 * @global string $search
+	 * @global string $comment_type
+	 */
+	public function prepare_items() {
+		global $post_id, $comment_status, $search;
+
+		$comment_status = isset( $_REQUEST['comment_status'] ) ? $_REQUEST['comment_status'] : 'all';
+		if ( ! in_array( $comment_status, array( 'all', 'mine', 'moderated', 'approved', 'spam', 'trash' ) ) ) {
+			$comment_status = 'all';
+		}
+
+		$search = ( isset( $_REQUEST['s'] ) ) ? $_REQUEST['s'] : '';
+
+		$post_type = ( isset( $_REQUEST['post_type'] ) ) ? sanitize_key( $_REQUEST['post_type'] ) : '';
+
+		$user_id = ( isset( $_REQUEST['user_id'] ) ) ? $_REQUEST['user_id'] : '';
+
+		$orderby = ( isset( $_REQUEST['orderby'] ) ) ? $_REQUEST['orderby'] : '';
+		$order   = ( isset( $_REQUEST['order'] ) ) ? $_REQUEST['order'] : '';
+
+		$feedbacks_per_page = $this->get_per_page( $comment_status );
+
+		$doing_ajax = wp_doing_ajax();
+
+		if ( isset( $_REQUEST['number'] ) ) {
+			$number = (int) $_REQUEST['number'];
+		} else {
+			$number = $feedbacks_per_page + min( 8, $feedbacks_per_page ); // Grab a few extra
+		}
+
+		$page = $this->get_pagenum();
+
+		if ( isset( $_REQUEST['start'] ) ) {
+			$start = $_REQUEST['start'];
+		} else {
+			$start = ( $page - 1 ) * $feedbacks_per_page;
+		}
+
+		if ( $doing_ajax && isset( $_REQUEST['offset'] ) ) {
+			$start += $_REQUEST['offset'];
+		}
+
+		$status_map = array(
+			'mine'      => '',
+			'moderated' => 'hold',
+			'approved'  => 'approve',
+			'all'       => '',
+		);
+
+		$args = array(
+			'status'    => isset( $status_map[ $comment_status ] ) ? $status_map[ $comment_status ] : $comment_status,
+			'search'    => $search,
+			'user_id'   => $user_id,
+			'offset'    => $start,
+			'number'    => $number,
+			'post_id'   => $post_id,
+			'type'      => $this->type,
+			'orderby'   => $orderby,
+			'order'     => $order,
+			'post_type' => $post_type,
+		);
+
+		/**
+		 * Filters the arguments for the comment query in the comments list table.
+		 *
+		 * @since 5.1.0
+		 *
+		 * @param array $args An array of get_comments() arguments.
+		 */
+		$args = apply_filters( 'comments_list_table_query_args', $args );
+
+		$_comments = get_comments( $args );
+		if ( is_array( $_comments ) ) {
+			update_comment_cache( $_comments );
+
+			$this->items       = array_slice( $_comments, 0, $feedbacks_per_page );
+			$this->extra_items = array_slice( $_comments, $feedbacks_per_page );
+		}
+
+		$total_feedbacks = get_comments(
+			array_merge(
+				$args,
+				array(
+					'count'  => true,
+					'offset' => 0,
+					'number' => 0,
+				)
+			)
+		);
+
+		$this->set_pagination_args(
+			array(
+				'total_items' => $total_feedbacks,
+				'per_page'    => $feedbacks_per_page,
+			)
+		);
+	}
+
+	/**
+	 * @param string $comment_status
+	 * @return int
+	 */
+	public function get_per_page( $comment_status = 'all' ) {
+		$feedbacks_per_page = $this->get_items_per_page( 'edit_' . $this->_args['plural'] . '_per_page' );
+		/**
+		 * Filters the number of comments listed per page in the comments list table.
+		 *
+		 * @since 2.6.0
+		 *
+		 * @param int    $feedbacks_per_page The number of comments to list per page.
+		 * @param string $comment_status    The comment status name. Default 'All'.
+		 */
+		return apply_filters( 'comments_per_page', $feedbacks_per_page, $comment_status );
+	}
+
+	/**
+	 * @global string $comment_status
+	 */
+	public function no_items() {
+		global $comment_status;
+
+		if ( 'moderated' === $comment_status ) {
+			_e( 'No comments awaiting moderation.' );
+		} else {
+			_e( 'No comments found.' );
+		}
+	}
+
+	/**
+	 * @global int $post_id
+	 * @global string $comment_status
+	 * @global string $comment_type
+	 */
+	protected function get_views() {
+		global $post_id, $comment_status;
+
+		$status_links = array();
+
+		if ( $post_id ) {
+			$this->num_comments = wp_count_comments( $post_id, $this->type );
+		} else {
+			$this->num_comments = wp_count_comments( 0, $this->type );
+		}
+
+		$stati = array(
+			/* translators: %s: Number of comments. */
+			'all'       => _nx_noop(
+				'All <span class="count">(%s)</span>',
+				'All <span class="count">(%s)</span>',
+				'comments'
+			), // singular not used
+
+			/* translators: %s: Number of comments. */
+			'mine'      => _nx_noop(
+				'Mine <span class="count">(%s)</span>',
+				'Mine <span class="count">(%s)</span>',
+				'comments'
+			),
+
+			/* translators: %s: Number of comments. */
+			'moderated' => _nx_noop(
+				'Pending <span class="count">(%s)</span>',
+				'Pending <span class="count">(%s)</span>',
+				'comments'
+			),
+
+			/* translators: %s: Number of comments. */
+			'approved'  => _nx_noop(
+				'Approved <span class="count">(%s)</span>',
+				'Approved <span class="count">(%s)</span>',
+				'comments'
+			),
+
+			/* translators: %s: Number of comments. */
+			'spam'      => _nx_noop(
+				'Spam <span class="count">(%s)</span>',
+				'Spam <span class="count">(%s)</span>',
+				'comments'
+			),
+
+			/* translators: %s: Number of comments. */
+			'trash'     => _nx_noop(
+				'Trash <span class="count">(%s)</span>',
+				'Trash <span class="count">(%s)</span>',
+				'comments'
+			),
+		);
+
+		if ( ! EMPTY_TRASH_DAYS ) {
+			unset( $stati['trash'] );
+		}
+
+		$link = admin_url( 'edit-feedbacks.php' );
+		if ( $this->type ) {
+			$link = add_query_arg( 'feedback_type', $this->type, $link );
+		}
+
+		foreach ( $stati as $status => $label ) {
+			$current_link_attributes = '';
+
+			if ( $status === $comment_status ) {
+				$current_link_attributes = ' class="current" aria-current="page"';
+			}
+
+			if ( 'mine' === $status ) {
+				$current_user_id          = get_current_user_id();
+				$this->num_comments->mine = get_comments(
+					array(
+						'post_id' => $post_id ? $post_id : 0,
+						'user_id' => $current_user_id,
+						'count'   => true,
+					)
+				);
+				$link                     = add_query_arg( 'user_id', $current_user_id, $link );
+			} else {
+				$link = remove_query_arg( 'user_id', $link );
+			}
+
+			if ( ! isset( $this->num_comments->$status ) ) {
+				$this->num_comments->$status = 10;
+			}
+			$link = add_query_arg( 'comment_status', $status, $link );
+			if ( $post_id ) {
+				$link = add_query_arg( 'p', absint( $post_id ), $link );
+			}
+			/*
+			// I toyed with this, but decided against it. Leaving it in here in case anyone thinks it is a good idea. ~ Mark
+			if ( !empty( $_REQUEST['s'] ) )
+				$link = add_query_arg( 's', esc_attr( wp_unslash( $_REQUEST['s'] ) ), $link );
+			*/
+			$status_links[ $status ] = "<a href='$link'$current_link_attributes>" . sprintf(
+				translate_nooped_plural( $label, $this->num_comments->$status ),
+				sprintf(
+					'<span class="%s-count">%s</span>',
+					( 'moderated' === $status ) ? 'pending' : $status,
+					number_format_i18n( $this->num_comments->$status )
+				)
+			) . '</a>';
+		}
+
+		// If some comments are awaiting moderation, get the number of pending feedback types per post.
+		if ( isset( $this->num_comments->moderated ) && $this->num_comments->moderated ) {
+			$_comment_post_ids = array_unique( wp_list_pluck( $this->items, 'comment_post_ID' ) );
+
+			$this->pending_count = get_pending_comments_num( $_comment_post_ids, $this->type );
+		}
+
+		/**
+		 * Filters the comment status links.
+		 *
+		 * @since 2.5.0
+		 * @since 5.1.0 The 'Mine' link was added.
+		 *
+		 * @param string[] $status_links An associative array of fully-formed comment status links. Includes 'All', 'Mine',
+		 *                              'Pending', 'Approved', 'Spam', and 'Trash'.
+		 */
+		return apply_filters( 'comment_status_links', $status_links );
+	}
+
+	/**
+	 * @global string $comment_status
+	 *
+	 * @return array
+	 */
+	protected function get_bulk_actions() {
+		global $comment_status;
+
+		$actions = array();
+		if ( in_array( $comment_status, array( 'all', 'approved' ) ) ) {
+			$actions['unapprove'] = __( 'Unapprove' );
+		}
+		if ( in_array( $comment_status, array( 'all', 'moderated' ) ) ) {
+			$actions['approve'] = __( 'Approve' );
+		}
+		if ( in_array( $comment_status, array( 'all', 'moderated', 'approved', 'trash' ) ) ) {
+			$actions['spam'] = _x( 'Mark as Spam', 'comment' );
+		}
+
+		if ( 'trash' === $comment_status ) {
+			$actions['untrash'] = __( 'Restore' );
+		} elseif ( 'spam' === $comment_status ) {
+			$actions['unspam'] = _x( 'Not Spam', 'comment' );
+		}
+
+		if ( in_array( $comment_status, array( 'trash', 'spam' ) ) || ! EMPTY_TRASH_DAYS ) {
+			$actions['delete'] = __( 'Delete Permanently' );
+		} else {
+			$actions['trash'] = __( 'Move to Trash' );
+		}
+
+		return $actions;
+	}
+
+	/**
+	 * @global string $comment_status
+	 * @global string $comment_type
+	 *
+	 * @param string $which
+	 */
+	protected function extra_tablenav( $which ) {
+		global $comment_status, $comment_type;
+		static $has_items;
+
+		if ( ! isset( $has_items ) ) {
+			$has_items = $this->has_items();
+		}
+		?>
+		<div class="alignleft actions">
+			<?php
+			if ( 'top' === $which ) {
+				/**
+				 * Fires just before the Filter submit button for comment types.
+				 *
+				 * @since 3.5.0
+				 */
+				do_action_deprecated( 'restrict_manage_comments', array(), '5.4.0' );
+			}
+
+			if ( ( 'spam' === $comment_status || 'trash' === $comment_status ) && current_user_can( 'moderate_comments' ) && $has_items ) {
+				wp_nonce_field( 'bulk-destroy', '_destroy_nonce' );
+				$title = ( 'spam' === $comment_status ) ? esc_attr__( 'Empty Spam' ) : esc_attr__( 'Empty Trash' );
+				submit_button( $title, 'apply', 'delete_all', false );
+			}
+
+			/**
+			 * Fires after the Filter submit button for comment types.
+			 *
+			 * @since 2.5.0
+			 *
+			 * @param string $comment_status The comment status name. Default 'All'.
+			 */
+			do_action( 'manage_comments_nav', $comment_status );
+			?>
+		</div>
+		<?php
+	}
+
+	/**
+	 * @return string|false
+	 */
+	public function current_action() {
+		if ( isset( $_REQUEST['delete_all'] ) || isset( $_REQUEST['delete_all2'] ) ) {
+			return 'delete_all';
+		}
+
+		return parent::current_action();
+	}
+
+	/**
+	 * @global int $post_id
+	 *
+	 * @return array
+	 */
+	public function get_columns() {
+		global $post_id;
+
+		$columns = array();
+
+		if ( $this->checkbox ) {
+			$columns['cb'] = '<input type="checkbox" />';
+		}
+
+		$columns['author']  = __( 'Author' );
+		$columns['comment'] = _x( 'Comment', 'column name' );
+
+		if ( ! $post_id ) {
+			/* translators: Column name or table row header. */
+			$columns['response'] = __( 'In Response To' );
+		}
+
+		$columns['date'] = _x( 'Submitted On', 'column name' );
+
+		return $columns;
+	}
+
+	/**
+	 * @return array
+	 */
+	protected function get_sortable_columns() {
+		return array(
+			'author'   => 'comment_author',
+			'response' => 'comment_post_ID',
+			'date'     => 'comment_date',
+		);
+	}
+
+	/**
+	 * Get the name of the default primary column.
+	 *
+	 * @since 4.3.0
+	 *
+	 * @return string Name of the default primary column, in this case, 'comment'.
+	 */
+	protected function get_default_primary_column_name() {
+		return 'comment';
+	}
+
+	/**
+	 * Displays the comments table.
+	 *
+	 * Overrides the parent display() method to render extra comments.
+	 *
+	 * @since 3.1.0
+	 */
+	public function display() {
+		wp_nonce_field( 'fetch-list-' . get_class( $this ), '_ajax_fetch_list_nonce' );
+
+		$this->display_tablenav( 'top' );
+
+		$this->screen->render_screen_reader_content( 'heading_list' );
+
+		?>
+<table class="wp-list-table <?php echo implode( ' ', $this->get_table_classes() ); ?>">
+	<thead>
+	<tr>
+		<?php $this->print_column_headers(); ?>
+	</tr>
+	</thead>
+
+	<tbody id="the-comment-list" data-wp-lists="list:comment">
+		<?php $this->display_rows_or_placeholder(); ?>
+	</tbody>
+
+	<tbody id="the-extra-comment-list" data-wp-lists="list:comment" style="display: none;">
+		<?php
+			/*
+			 * Back up the items to restore after printing the extra items markup.
+			 * The extra items may be empty, which will prevent the table nav from displaying later.
+			 */
+			$items       = $this->items;
+			$this->items = $this->extra_items;
+			$this->display_rows_or_placeholder();
+			$this->items = $items;
+		?>
+	</tbody>
+
+	<tfoot>
+	<tr>
+		<?php $this->print_column_headers( false ); ?>
+	</tr>
+	</tfoot>
+
+</table>
+		<?php
+
+		$this->display_tablenav( 'bottom' );
+	}
+
+	/**
+	 * @global WP_Post    $post    Global post object.
+	 * @global WP_Comment $comment Global comment object.
+	 *
+	 * @param WP_Comment $item
+	 */
+	public function single_row( $item ) {
+		global $post, $comment;
+
+		$comment = $item;
+
+		$the_comment_class = wp_get_comment_status( $comment );
+		if ( ! $the_comment_class ) {
+			$the_comment_class = '';
+		}
+		$the_comment_class = join( ' ', get_comment_class( $the_comment_class, $comment, $comment->comment_post_ID ) );
+
+		if ( $comment->comment_post_ID > 0 ) {
+			$post = get_post( $comment->comment_post_ID );
+		}
+		$this->user_can = current_user_can( 'edit_comment', $comment->comment_ID );
+
+		echo "<tr id='comment-$comment->comment_ID' class='$the_comment_class'>";
+		$this->single_row_columns( $comment );
+		echo "</tr>\n";
+
+		unset( $GLOBALS['post'], $GLOBALS['comment'] );
+	}
+
+	/**
+	 * Generate and display row actions links.
+	 *
+	 * @since 4.3.0
+	 *
+	 * @global string $comment_status Status for the current listed comments.
+	 *
+	 * @param WP_Comment $comment     The comment object.
+	 * @param string     $column_name Current column name.
+	 * @param string     $primary     Primary column name.
+	 * @return string|void Comment row actions output.
+	 */
+	protected function handle_row_actions( $comment, $column_name, $primary ) {
+		global $comment_status;
+
+		if ( $primary !== $column_name ) {
+			return '';
+		}
+
+		if ( ! $this->user_can ) {
+			return;
+		}
+
+		$the_comment_status = wp_get_comment_status( $comment );
+
+		$out = '';
+
+		$del_nonce     = esc_html( '_wpnonce=' . wp_create_nonce( "delete-comment_$comment->comment_ID" ) );
+		$approve_nonce = esc_html( '_wpnonce=' . wp_create_nonce( "approve-comment_$comment->comment_ID" ) );
+
+		$url = "comment.php?c=$comment->comment_ID";
+
+		$approve_url   = esc_url( $url . "&action=approvecomment&$approve_nonce" );
+		$unapprove_url = esc_url( $url . "&action=unapprovecomment&$approve_nonce" );
+		$spam_url      = esc_url( $url . "&action=spamcomment&$del_nonce" );
+		$unspam_url    = esc_url( $url . "&action=unspamcomment&$del_nonce" );
+		$trash_url     = esc_url( $url . "&action=trashcomment&$del_nonce" );
+		$untrash_url   = esc_url( $url . "&action=untrashcomment&$del_nonce" );
+		$delete_url    = esc_url( $url . "&action=deletecomment&$del_nonce" );
+
+		// Preorder it: Approve | Reply | Quick Edit | Edit | Spam | Trash.
+		$actions = array(
+			'approve'   => '',
+			'unapprove' => '',
+			'reply'     => '',
+			'quickedit' => '',
+			'edit'      => '',
+			'spam'      => '',
+			'unspam'    => '',
+			'trash'     => '',
+			'untrash'   => '',
+			'delete'    => '',
+		);
+
+		// Not looking at all comments.
+		if ( $comment_status && 'all' != $comment_status ) {
+			if ( 'approved' === $the_comment_status ) {
+				$actions['unapprove'] = sprintf(
+					'<a href="%s" data-wp-lists="%s" class="vim-u vim-destructive aria-button-if-js" aria-label="%s">%s</a>',
+					$unapprove_url,
+					"delete:the-comment-list:comment-{$comment->comment_ID}:e7e7d3:action=dim-comment&amp;new=unapproved",
+					esc_attr__( 'Unapprove this comment' ),
+					__( 'Unapprove' )
+				);
+			} elseif ( 'unapproved' === $the_comment_status ) {
+				$actions['approve'] = sprintf(
+					'<a href="%s" data-wp-lists="%s" class="vim-a vim-destructive aria-button-if-js" aria-label="%s">%s</a>',
+					$approve_url,
+					"delete:the-comment-list:comment-{$comment->comment_ID}:e7e7d3:action=dim-comment&amp;new=approved",
+					esc_attr__( 'Approve this comment' ),
+					__( 'Approve' )
+				);
+			}
+		} else {
+			$actions['approve'] = sprintf(
+				'<a href="%s" data-wp-lists="%s" class="vim-a aria-button-if-js" aria-label="%s">%s</a>',
+				$approve_url,
+				"dim:the-comment-list:comment-{$comment->comment_ID}:unapproved:e7e7d3:e7e7d3:new=approved",
+				esc_attr__( 'Approve this comment' ),
+				__( 'Approve' )
+			);
+
+			$actions['unapprove'] = sprintf(
+				'<a href="%s" data-wp-lists="%s" class="vim-u aria-button-if-js" aria-label="%s">%s</a>',
+				$unapprove_url,
+				"dim:the-comment-list:comment-{$comment->comment_ID}:unapproved:e7e7d3:e7e7d3:new=unapproved",
+				esc_attr__( 'Unapprove this comment' ),
+				__( 'Unapprove' )
+			);
+		}
+
+		if ( 'spam' !== $the_comment_status ) {
+			$actions['spam'] = sprintf(
+				'<a href="%s" data-wp-lists="%s" class="vim-s vim-destructive aria-button-if-js" aria-label="%s">%s</a>',
+				$spam_url,
+				"delete:the-comment-list:comment-{$comment->comment_ID}::spam=1",
+				esc_attr__( 'Mark this comment as spam' ),
+				/* translators: "Mark as spam" link. */
+				_x( 'Spam', 'verb' )
+			);
+		} elseif ( 'spam' === $the_comment_status ) {
+			$actions['unspam'] = sprintf(
+				'<a href="%s" data-wp-lists="%s" class="vim-z vim-destructive aria-button-if-js" aria-label="%s">%s</a>',
+				$unspam_url,
+				"delete:the-comment-list:comment-{$comment->comment_ID}:66cc66:unspam=1",
+				esc_attr__( 'Restore this comment from the spam' ),
+				_x( 'Not Spam', 'comment' )
+			);
+		}
+
+		if ( 'trash' === $the_comment_status ) {
+			$actions['untrash'] = sprintf(
+				'<a href="%s" data-wp-lists="%s" class="vim-z vim-destructive aria-button-if-js" aria-label="%s">%s</a>',
+				$untrash_url,
+				"delete:the-comment-list:comment-{$comment->comment_ID}:66cc66:untrash=1",
+				esc_attr__( 'Restore this comment from the Trash' ),
+				__( 'Restore' )
+			);
+		}
+
+		if ( 'spam' === $the_comment_status || 'trash' === $the_comment_status || ! EMPTY_TRASH_DAYS ) {
+			$actions['delete'] = sprintf(
+				'<a href="%s" data-wp-lists="%s" class="delete vim-d vim-destructive aria-button-if-js" aria-label="%s">%s</a>',
+				$delete_url,
+				"delete:the-comment-list:comment-{$comment->comment_ID}::delete=1",
+				esc_attr__( 'Delete this comment permanently' ),
+				__( 'Delete Permanently' )
+			);
+		} else {
+			$actions['trash'] = sprintf(
+				'<a href="%s" data-wp-lists="%s" class="delete vim-d vim-destructive aria-button-if-js" aria-label="%s">%s</a>',
+				$trash_url,
+				"delete:the-comment-list:comment-{$comment->comment_ID}::trash=1",
+				esc_attr__( 'Move this comment to the Trash' ),
+				_x( 'Trash', 'verb' )
+			);
+		}
+
+		if ( 'spam' !== $the_comment_status && 'trash' !== $the_comment_status ) {
+			$actions['edit'] = sprintf(
+				'<a href="%s" aria-label="%s">%s</a>',
+				"comment.php?action=editcomment&amp;c={$comment->comment_ID}",
+				esc_attr__( 'Edit this comment' ),
+				__( 'Edit' )
+			);
+
+			$format = '<button type="button" data-comment-id="%d" data-post-id="%d" data-action="%s" class="%s button-link" aria-expanded="false" aria-label="%s">%s</button>';
+
+			$actions['quickedit'] = sprintf(
+				$format,
+				$comment->comment_ID,
+				$comment->comment_post_ID,
+				'edit',
+				'vim-q comment-inline',
+				esc_attr__( 'Quick edit this comment inline' ),
+				__( 'Quick&nbsp;Edit' )
+			);
+
+			$actions['reply'] = sprintf(
+				$format,
+				$comment->comment_ID,
+				$comment->comment_post_ID,
+				'replyto',
+				'vim-r comment-inline',
+				esc_attr__( 'Reply to this comment' ),
+				__( 'Reply' )
+			);
+		}
+
+		/** This filter is documented in wp-admin/includes/dashboard.php */
+		$actions = apply_filters( 'comment_row_actions', array_filter( $actions ), $comment );
+
+		$i    = 0;
+		$out .= '<div class="row-actions">';
+		foreach ( $actions as $action => $link ) {
+			++$i;
+			( ( ( 'approve' === $action || 'unapprove' === $action ) && 2 === $i ) || 1 === $i ) ? $sep = '' : $sep = ' | ';
+
+			// Reply and quickedit need a hide-if-no-js span when not added with ajax
+			if ( ( 'reply' === $action || 'quickedit' === $action ) && ! wp_doing_ajax() ) {
+				$action .= ' hide-if-no-js';
+			} elseif ( ( $action === 'untrash' && $the_comment_status === 'trash' ) || ( $action === 'unspam' && $the_comment_status === 'spam' ) ) {
+				if ( '1' == get_comment_meta( $comment->comment_ID, '_wp_trash_meta_status', true ) ) {
+					$action .= ' approve';
+				} else {
+					$action .= ' unapprove';
+				}
+			}
+
+			$out .= "<span class='$action'>$sep$link</span>";
+		}
+		$out .= '</div>';
+
+		$out .= '<button type="button" class="toggle-row"><span class="screen-reader-text">' . __( 'Show more details' ) . '</span></button>';
+
+		return $out;
+	}
+
+	/**
+	 * @param WP_Comment $comment The comment object.
+	 */
+	public function column_cb( $comment ) {
+		if ( $this->user_can ) {
+			?>
+		<label class="screen-reader-text" for="cb-select-<?php echo $comment->comment_ID; ?>"><?php _e( 'Select comment' ); ?></label>
+		<input id="cb-select-<?php echo $comment->comment_ID; ?>" type="checkbox" name="delete_comments[]" value="<?php echo $comment->comment_ID; ?>" />
+			<?php
+		}
+	}
+
+	/**
+	 * @param WP_Comment $comment The comment object.
+	 */
+	public function column_comment( $comment ) {
+		echo '<div class="comment-author">';
+			$this->column_author( $comment );
+		echo '</div>';
+
+		if ( $comment->comment_parent ) {
+			$parent = get_comment( $comment->comment_parent );
+			if ( $parent ) {
+				$parent_link = esc_url( get_comment_link( $parent ) );
+				$name        = get_comment_author( $parent );
+				printf(
+					/* translators: %s: Comment link. */
+					__( 'In reply to %s.' ),
+					'<a href="' . $parent_link . '">' . $name . '</a>'
+				);
+			}
+		}
+
+		comment_text( $comment );
+
+		if ( $this->user_can ) {
+			/** This filter is documented in wp-admin/includes/comment.php */
+			$comment_content = apply_filters( 'comment_edit_pre', $comment->comment_content );
+			?>
+		<div id="inline-<?php echo $comment->comment_ID; ?>" class="hidden">
+			<textarea class="comment" rows="1" cols="1"><?php echo esc_textarea( $comment_content ); ?></textarea>
+			<div class="author-email"><?php echo esc_attr( $comment->comment_author_email ); ?></div>
+			<div class="author"><?php echo esc_attr( $comment->comment_author ); ?></div>
+			<div class="author-url"><?php echo esc_attr( $comment->comment_author_url ); ?></div>
+			<div class="comment_status"><?php echo $comment->comment_approved; ?></div>
+		</div>
+			<?php
+		}
+	}
+
+	/**
+	 * @global string $comment_status
+	 *
+	 * @param WP_Comment $comment The comment object.
+	 */
+	public function column_author( $comment ) {
+		global $comment_status;
+
+		$author_url = get_comment_author_url( $comment );
+
+		$author_url_display = untrailingslashit( preg_replace( '|^http(s)?://(www\.)?|i', '', $author_url ) );
+		if ( strlen( $author_url_display ) > 50 ) {
+			$author_url_display = wp_html_excerpt( $author_url_display, 49, '&hellip;' );
+		}
+
+		echo '<strong>';
+		comment_author( $comment );
+		echo '</strong><br />';
+		if ( ! empty( $author_url_display ) ) {
+			printf( '<a href="%s">%s</a><br />', esc_url( $author_url ), esc_html( $author_url_display ) );
+		}
+
+		if ( $this->user_can ) {
+			if ( ! empty( $comment->comment_author_email ) ) {
+				/** This filter is documented in wp-includes/comment-template.php */
+				$email = apply_filters( 'comment_email', $comment->comment_author_email, $comment );
+
+				if ( ! empty( $email ) && '@' !== $email ) {
+					printf( '<a href="%1$s">%2$s</a><br />', esc_url( 'mailto:' . $email ), esc_html( $email ) );
+				}
+			}
+
+			$author_ip = get_comment_author_IP( $comment );
+			if ( $author_ip ) {
+				$author_ip_url = add_query_arg(
+					array(
+						's'    => $author_ip,
+						'mode' => 'detail',
+					),
+					admin_url( 'edit-comments.php' )
+				);
+				if ( 'spam' === $comment_status ) {
+					$author_ip_url = add_query_arg( 'comment_status', 'spam', $author_ip_url );
+				}
+				printf( '<a href="%1$s">%2$s</a>', esc_url( $author_ip_url ), esc_html( $author_ip ) );
+			}
+		}
+	}
+
+	/**
+	 * @param WP_Comment $comment The comment object.
+	 */
+	public function column_date( $comment ) {
+		$submitted = sprintf(
+			/* translators: 1: Comment date, 2: Comment time. */
+			__( '%1$s at %2$s' ),
+			/* translators: Comment date format. See https://secure.php.net/date */
+			get_comment_date( __( 'Y/m/d' ), $comment ),
+			/* translators: Comment time format. See https://secure.php.net/date */
+			get_comment_date( __( 'g:i a' ), $comment )
+		);
+
+		echo '<div class="submitted-on">';
+		if ( 'approved' === wp_get_comment_status( $comment ) && ! empty( $comment->comment_post_ID ) ) {
+			printf(
+				'<a href="%s">%s</a>',
+				esc_url( get_comment_link( $comment ) ),
+				$submitted
+			);
+		} else {
+			echo $submitted;
+		}
+		echo '</div>';
+	}
+
+	/**
+	 * @param WP_Comment $comment The comment object.
+	 */
+	public function column_response( $comment ) {
+		$post = get_post();
+
+		if ( ! $post ) {
+			return;
+		}
+
+		if ( isset( $this->pending_count[ $post->ID ] ) ) {
+			$pending_comments = $this->pending_count[ $post->ID ];
+		} else {
+			$_pending_count_temp              = get_pending_comments_num( array( $post->ID ), $this->type );
+			$pending_comments                 = $_pending_count_temp[ $post->ID ];
+			$this->pending_count[ $post->ID ] = $pending_comments;
+		}
+
+		if ( current_user_can( 'edit_post', $post->ID ) ) {
+			$post_link  = "<a href='" . get_edit_post_link( $post->ID ) . "' class='comments-edit-item-link'>";
+			$post_link .= esc_html( get_the_title( $post->ID ) ) . '</a>';
+		} else {
+			$post_link = esc_html( get_the_title( $post->ID ) );
+		}
+
+		echo '<div class="response-links">';
+		if ( 'attachment' === $post->post_type ) {
+			$thumb = wp_get_attachment_image( $post->ID, array( 80, 60 ), true );
+			if ( $thumb ) {
+				echo $thumb;
+			}
+		}
+		echo $post_link;
+		$post_type_object = get_post_type_object( $post->post_type );
+		echo "<a href='" . get_permalink( $post->ID ) . "' class='comments-view-item-link'>" . $post_type_object->labels->view_item . '</a>';
+		echo '<span class="post-com-count-wrapper post-com-count-', $post->ID, '">';
+
+		add_filter( 'get_comments_number', array( $this, 'get_comments_number_by_type' ), 10, 2 );
+		$this->comments_bubble( $post->ID, $pending_comments );
+		remove_filter( 'get_comments_number', array( $this, 'get_comments_number_by_type' ), 10, 2 );
+
+		echo '</span> ';
+		echo '</div>';
+	}
+
+	/**
+	 * Adapt the comment count bubble to the displayed type.
+	 *
+	 * @since 5.4.0
+	 *
+	 * @param string|int $count   A string representing the number of comments a post has, otherwise 0.
+	 * @param int        $post_id The post ID.
+	 */
+	public function get_comments_number_by_type( $count, $post_id ) {
+		$count = wp_count_comments( $post_id, $this->type );
+
+		return $count->approved;
+	}
+
+	/**
+	 * @param WP_Comment $comment     The comment object.
+	 * @param string     $column_name The custom column's name.
+	 */
+	public function column_default( $comment, $column_name ) {
+		/**
+		 * Fires when the default column output is displayed for a single row.
+		 *
+		 * @since 2.8.0
+		 *
+		 * @param string $column_name         The custom column's name.
+		 * @param int    $comment->comment_ID The custom column's unique ID number.
+		 */
+		do_action( 'manage_comments_custom_column', $column_name, $comment->comment_ID );
+	}
+}
diff --git src/wp-admin/includes/class-wp-screen.php src/wp-admin/includes/class-wp-screen.php
index 3a06e3a34a..9839a3964a 100644
--- src/wp-admin/includes/class-wp-screen.php
+++ src/wp-admin/includes/class-wp-screen.php
@@ -213,6 +213,7 @@ final class WP_Screen {
 
 		$post_type       = null;
 		$taxonomy        = null;
+		$feedback_type   = null;
 		$in_admin        = false;
 		$action          = '';
 		$is_block_editor = false;
@@ -248,7 +249,7 @@ final class WP_Screen {
 			}
 
 			$id = sanitize_key( $id );
-			if ( 'edit-comments' != $id && 'edit-tags' != $id && 'edit-' == substr( $id, 0, 5 ) ) {
+			if ( 'edit-comments' != $id && 'edit-feedbacks' != $id && 'edit-tags' != $id && 'edit-' == substr( $id, 0, 5 ) ) {
 				$maybe = substr( $id, 5 );
 				if ( taxonomy_exists( $maybe ) ) {
 					$id       = 'edit-tags';
@@ -289,6 +290,10 @@ final class WP_Screen {
 				$taxonomy = taxonomy_exists( $_REQUEST['taxonomy'] ) ? $_REQUEST['taxonomy'] : false;
 			}
 
+			if ( isset( $_REQUEST['feedback_type'] ) ) {
+				$feedback_type = feedback_type_exists( $_REQUEST['feedback_type'] ) ? $_REQUEST['feedback_type'] : false;
+			}
+
 			switch ( $base ) {
 				case 'post':
 					if ( isset( $_GET['post'] ) && isset( $_POST['post_ID'] ) && (int) $_GET['post'] !== (int) $_POST['post_ID'] ) {
@@ -346,6 +351,12 @@ final class WP_Screen {
 				}
 				$id .= '-' . $post_type;
 				break;
+			case 'edit-feedbacks':
+				if ( null === $feedback_type ) {
+					$feedback_type = 'comment';
+				}
+				$id .= '-' . $feedback_type;
+				break;
 			case 'edit-tags':
 			case 'term':
 				if ( null === $taxonomy ) {
@@ -385,6 +396,7 @@ final class WP_Screen {
 		$screen->action          = $action;
 		$screen->post_type       = (string) $post_type;
 		$screen->taxonomy        = (string) $taxonomy;
+		$screen->feedback_type   = (string) $feedback_type;
 		$screen->is_user         = ( 'user' == $in_admin );
 		$screen->is_network      = ( 'network' == $in_admin );
 		$screen->in_admin        = $in_admin;
@@ -406,10 +418,11 @@ final class WP_Screen {
 	 * @global string    $typenow
 	 */
 	public function set_current_screen() {
-		global $current_screen, $taxnow, $typenow;
+		global $current_screen, $taxnow, $typenow, $feedback_type;
 		$current_screen = $this;
 		$taxnow         = $this->taxonomy;
 		$typenow        = $this->post_type;
+		$feedback_type  = $this->feedback_type;
 
 		/**
 		 * Fires after the current screen has been set.
diff --git src/wp-admin/includes/comment.php src/wp-admin/includes/comment.php
index 4000fe7a36..d2f79f6512 100644
--- src/wp-admin/includes/comment.php
+++ src/wp-admin/includes/comment.php
@@ -135,13 +135,15 @@ function get_comment_to_edit( $id ) {
  * Get the number of pending comments on a post or posts
  *
  * @since 2.3.0
+ * @since 5.4.0 Adds the $type parameter.
  *
  * @global wpdb $wpdb WordPress database abstraction object.
  *
  * @param int|array $post_id Either a single Post ID or an array of Post IDs
+ * @param string    $type    Optional. Restrict comment counts to a specific type.
  * @return int|array Either a single Posts pending comments as an int or an array of ints keyed on the Post IDs
  */
-function get_pending_comments_num( $post_id ) {
+function get_pending_comments_num( $post_id, $type = '' ) {
 	global $wpdb;
 
 	$single = false;
@@ -154,7 +156,17 @@ function get_pending_comments_num( $post_id ) {
 	$post_id_array = array_map( 'intval', $post_id_array );
 	$post_id_in    = "'" . implode( "', '", $post_id_array ) . "'";
 
-	$pending = $wpdb->get_results( "SELECT comment_post_ID, COUNT(comment_ID) as num_comments FROM $wpdb->comments WHERE comment_post_ID IN ( $post_id_in ) AND comment_approved = '0' GROUP BY comment_post_ID", ARRAY_A );
+	$type_clause = '';
+	if ( $type && in_array( $type, get_feedback_types(), true ) ) {
+		$type_clause = ' AND comment_type = %s';
+		if ( 'comment' === $type ) {
+			$type_clause = ' AND ( comment_type = \'\' OR comment_type = %s )';
+		}
+
+		$type_clause = $wpdb->prepare( $type_clause, $type );
+	}
+
+	$pending = $wpdb->get_results( "SELECT comment_post_ID, COUNT(comment_ID) as num_comments FROM $wpdb->comments WHERE comment_post_ID IN ( $post_id_in ) AND comment_approved = '0' {$type_clause} GROUP BY comment_post_ID", ARRAY_A );
 
 	if ( $single ) {
 		if ( empty( $pending ) ) {
diff --git src/wp-admin/includes/list-table.php src/wp-admin/includes/list-table.php
index dce5eef702..5b7c1954dd 100644
--- src/wp-admin/includes/list-table.php
+++ src/wp-admin/includes/list-table.php
@@ -27,6 +27,7 @@ function _get_list_table( $class, $args = array() ) {
 		'WP_Terms_List_Table'                         => 'terms',
 		'WP_Users_List_Table'                         => 'users',
 		'WP_Comments_List_Table'                      => 'comments',
+		'WP_Feedbacks_List_Table'                     => 'feedbacks',
 		'WP_Post_Comments_List_Table'                 => array( 'comments', 'post-comments' ),
 		'WP_Links_List_Table'                         => 'links',
 		'WP_Plugin_Install_List_Table'                => 'plugin-install',
diff --git src/wp-admin/menu.php src/wp-admin/menu.php
index 77cf7d68bd..3766cd4ef7 100644
--- src/wp-admin/menu.php
+++ src/wp-admin/menu.php
@@ -94,9 +94,9 @@ if ( current_user_can( 'edit_posts' ) ) {
 
 	$menu[25] = array(
 		/* translators: %s: Number of comments. */
-		sprintf( __( 'Comments %s' ), '<span class="awaiting-mod count-' . absint( $awaiting_mod ) . '"><span class="pending-count" aria-hidden="true">' . $awaiting_mod_i18n . '</span><span class="comments-in-moderation-text screen-reader-text">' . $awaiting_mod_text . '</span></span>' ),
+		sprintf( __( 'Feedbacks %s' ), '<span class="awaiting-mod count-' . absint( $awaiting_mod ) . '"><span class="pending-count" aria-hidden="true">' . $awaiting_mod_i18n . '</span><span class="comments-in-moderation-text screen-reader-text">' . $awaiting_mod_text . '</span></span>' ),
 		'edit_posts',
-		'edit-comments.php',
+		'edit-feedbacks.php',
 		'',
 		'menu-top menu-icon-comments',
 		'menu-comments',
@@ -105,7 +105,7 @@ if ( current_user_can( 'edit_posts' ) ) {
 	unset( $awaiting_mod );
 }
 
-$submenu['edit-comments.php'][0] = array( __( 'All Comments' ), 'edit_posts', 'edit-comments.php' );
+$submenu['edit-feedbacks.php'][0] = array( __( 'All Feedbacks' ), 'edit_posts', 'edit-feedbacks.php' );
 
 $_wp_last_object_menu = 25; // The index of the last top-level menu in the object menu group.
 
diff --git src/wp-includes/admin-bar.php src/wp-includes/admin-bar.php
index 8799583eb7..64961d8bf6 100644
--- src/wp-includes/admin-bar.php
+++ src/wp-includes/admin-bar.php
@@ -624,8 +624,8 @@ function wp_admin_bar_my_sites_menu( $wp_admin_bar ) {
 				array(
 					'parent' => $menu_id,
 					'id'     => $menu_id . '-c',
-					'title'  => __( 'Manage Comments' ),
-					'href'   => admin_url( 'edit-comments.php' ),
+					'title'  => __( 'Manage Feedbacks' ),
+					'href'   => admin_url( 'edit-feedbacks.php' ),
 				)
 			);
 		}
@@ -896,8 +896,8 @@ function wp_admin_bar_comments_menu( $wp_admin_bar ) {
 	$awaiting_mod  = wp_count_comments();
 	$awaiting_mod  = $awaiting_mod->moderated;
 	$awaiting_text = sprintf(
-		/* translators: %s: Number of comments. */
-		_n( '%s Comment in moderation', '%s Comments in moderation', $awaiting_mod ),
+		/* translators: %s: Number of feedbacks. */
+		_n( '%s Feedback in moderation', '%s Feedbacks in moderation', $awaiting_mod ),
 		number_format_i18n( $awaiting_mod )
 	);
 
@@ -909,7 +909,7 @@ function wp_admin_bar_comments_menu( $wp_admin_bar ) {
 		array(
 			'id'    => 'comments',
 			'title' => $icon . $title,
-			'href'  => admin_url( 'edit-comments.php' ),
+			'href'  => admin_url( 'edit-feedbacks.php' ),
 		)
 	);
 }
diff --git src/wp-includes/class-wp-feedback-type.php src/wp-includes/class-wp-feedback-type.php
new file mode 100644
index 0000000000..41edbe864c
--- /dev/null
+++ src/wp-includes/class-wp-feedback-type.php
@@ -0,0 +1,308 @@
+<?php
+/**
+ * Feedback API: WP_Feedback_Type class
+ *
+ * @package WordPress
+ * @subpackage Feedback
+ * @since 5.4.0
+ */
+
+/**
+ * Core class used for interacting with feedback types.
+ *
+ * @since 5.4.0
+ *
+ * @see register_feedback_type()
+ */
+final class WP_Feedback_Type {
+	/**
+	 * Feedback type key.
+	 *
+	 * @since 5.4.0
+	 * @var string $name
+	 */
+	public $name;
+
+	/**
+	 * Name of the feedback type shown in the navigation. Usually plural.
+	 *
+	 * @since 5.4.0
+	 * @var string $label
+	 */
+	public $label;
+
+	/**
+	 * Labels object for this feedback type.
+	 *
+	 * @see get_feedback_type_labels()
+	 *
+	 * @since 5.4.0
+	 * @var object $labels
+	 */
+	public $labels;
+
+	/**
+	 * Feedback type plural key name.
+	 *
+	 * @since 5.4.0
+	 * @var string $plural
+	 */
+	public $plural;
+
+	/**
+	 * Feedback type singular key name.
+	 *
+	 * @since 5.4.0
+	 * @var string $singular
+	 */
+	public $singular;
+
+	/**
+	 * A short descriptive summary of what the feedback type is.
+	 *
+	 * Default empty.
+	 *
+	 * @since 5.4.0
+	 * @var string $description
+	 */
+	public $description = '';
+
+	/**
+	 * Whether a feedback type is intended for use publicly either via the admin interface or by front-end users.
+	 *
+	 * Default false.
+	 *
+	 * @since 5.4.0
+	 * @var bool $public
+	 */
+	public $public = false;
+
+	/**
+	 * Whether to generate and allow a UI for managing this feedback type in the admin.
+	 *
+	 * Default is the value of $public.
+	 *
+	 * @since 5.4.0
+	 * @var bool $show_ui
+	 */
+	public $show_ui = null;
+
+	/**
+	 * The position in the navigation order the feedback type should appear.
+	 *
+	 * To work, $show_in_menu must be true. Default null (at the bottom).
+	 *
+	 * @since 4.6.0
+	 * @var int $menu_position
+	 */
+	public $nav_position = null;
+
+	/**
+	 * Whether to delete feedbacks of this type when deleting a user.
+	 *
+	 * @since 5.4.0
+	 * @var bool $delete_with_user
+	 */
+	public $delete_with_user = null;
+
+	/**
+	 * Whether this feedback type is a native or "built-in" feedback_type.
+	 *
+	 * Default false.
+	 *
+	 * @since 5.4.0
+	 * @var bool $_builtin
+	 */
+	public $_builtin = false;
+
+	/**
+	 * URL segment to use for edit link of this feedback type.
+	 *
+	 * Default 'feedback.php?feedback=%d'.
+	 *
+	 * @since 5.4.0
+	 * @var string $_edit_link
+	 */
+	public $_edit_link = 'feedback.php?feedback=%d';
+
+	/**
+	 * Feedback type capabilities.
+	 *
+	 * @since 5.4.0
+	 * @var object $capabilities
+	 */
+	public $capabilities;
+
+	/**
+	 * The features supported by the feedback type.
+	 *
+	 * @since 5.4.0
+	 * @var array|bool $supports
+	 */
+	public $supports;
+
+	/**
+	 * Whether this feedback type should appear in the REST API..
+	 *
+	 * @since 5.4.0
+	 * @var bool $show_in_rest
+	 */
+	public $show_in_rest;
+
+	/**
+	 * The base path for this feedback type's REST API endpoints.
+	 *
+	 * @since 5.4.0
+	 * @var string|bool $rest_base
+	 */
+	public $rest_base;
+
+	/**
+	 * The controller for this feedback type's REST API endpoints.
+	 *
+	 * Custom controllers must extend WP_REST_Controller.
+	 *
+	 * @since 5.4.0
+	 * @var string|bool $rest_controller_class
+	 */
+	public $rest_controller_class;
+
+	/**
+	 * The controller instance for this feedback type's REST API endpoints.
+	 *
+	 * Lazily computed. Should be accessed using {@see WP_Feedback_Type::get_rest_controller()}.
+	 *
+	 * @since 5.4.0
+	 * @var WP_REST_Controller $rest_controller
+	 */
+	public $rest_controller;
+
+	/**
+	 * Constructor.
+	 *
+	 * Will populate object properties from the provided arguments and assign other
+	 * default properties based on that information.
+	 *
+	 * @since 5.4.0
+	 *
+	 * @see register_feedback_type()
+	 *
+	 * @param string       $feedback_type Feedback type key.
+	 * @param array|string $args          Optional. Array or string of arguments for registering a feedback type.
+	 *                                    Default empty array.
+	 */
+	public function __construct( $feedback_type, $args = array() ) {
+		$this->name = $feedback_type;
+
+		$this->set_props( $args );
+	}
+
+	/**
+	 * Sets feedback type properties.
+	 *
+	 * @since 5.4.0
+	 *
+	 * @param array|string $args Array or string of arguments for registering a feedback type.
+	 */
+	public function set_props( $args ) {
+		$args = wp_parse_args( $args );
+
+		/**
+		 * Filters the arguments for registering a feedback type.
+		 *
+		 * @since 4.4.0
+		 *
+		 * @param array  $args          Array of arguments for registering a feedback type.
+		 * @param string $feedback_type Feedback type key.
+		 */
+		$args = apply_filters( 'register_feedback_type_args', $args, $this->name );
+
+		$has_edit_link = ! empty( $args['_edit_link'] );
+
+		// Args prefixed with an underscore are reserved for internal use.
+		$defaults = array(
+			'labels'                => array(),
+			'plural'                => null,
+			'singular'              => null,
+			'description'           => '',
+			'public'                => false,
+			'show_ui'               => null,
+			'nav_position'          => null,
+			'capabilities'          => array(),
+			'supports'              => array(),
+			'delete_with_user'      => null,
+			'show_in_rest'          => false,
+			'rest_base'             => false,
+			'rest_controller_class' => false,
+			'_builtin'              => false,
+			'_edit_link'            => 'feedback.php?feedback=%d',
+		);
+
+		$args = array_merge( $defaults, $args );
+
+		$args['name'] = $this->name;
+
+		// If not set, default to the feedback type key.
+		if ( null === $args['singular'] ) {
+			$args['singular'] = $this->name;
+		}
+
+		// If not set, default to the plural of the feedback singular key name.
+		if ( null === $args['plural'] ) {
+			$args['plural'] = $args['singular'] . 's';
+		}
+
+		// If not set, default to the setting for public.
+		if ( null === $args['show_ui'] ) {
+			$args['show_ui'] = $args['public'];
+		}
+
+		// If there's no specified edit link and no UI, remove the edit link.
+		if ( ! $args['show_ui'] && ! $has_edit_link ) {
+			$args['_edit_link'] = '';
+		}
+
+		foreach ( $args as $property_name => $property_value ) {
+			$this->$property_name = $property_value;
+		}
+
+		$this->labels = get_feedback_type_labels( $this );
+		$this->label  = $this->labels->name;
+	}
+
+	/**
+	 * Gets the REST API controller for this feedback type.
+	 *
+	 * Will only instantiate the controller class once per request.
+	 *
+	 * @since 5.4.0
+	 *
+	 * @return WP_REST_Controller|null The controller instance, or null if the feedback type
+	 *                                 is set not to show in rest.
+	 */
+	public function get_rest_controller() {
+		if ( ! $this->show_in_rest ) {
+			return null;
+		}
+
+		$class = $this->rest_controller_class ? $this->rest_controller_class : WP_REST_Comments_Controller::class;
+
+		if ( ! class_exists( $class ) ) {
+			return null;
+		}
+
+		if ( ! is_subclass_of( $class, WP_REST_Controller::class ) ) {
+			return null;
+		}
+
+		if ( ! $this->rest_controller ) {
+			$this->rest_controller = new $class( $this->name );
+		}
+
+		if ( ! ( $this->rest_controller instanceof $class ) ) {
+			return null;
+		}
+
+		return $this->rest_controller;
+	}
+}
diff --git src/wp-includes/comment.php src/wp-includes/comment.php
index 15cb44bcc3..f8fc6bb816 100644
--- src/wp-includes/comment.php
+++ src/wp-includes/comment.php
@@ -360,11 +360,14 @@ function get_lastcommentmodified( $timezone = 'server' ) {
  * Unlike wp_count_comments(), this function always returns the live comment counts without caching.
  *
  * @since 2.0.0
+ * @since 5.4.0 Adds the $type parameter.
  *
  * @global wpdb $wpdb WordPress database abstraction object.
  *
  * @param int $post_id Optional. Restrict the comment counts to the given post. Default 0, which indicates that
  *                     comment counts for the whole site will be retrieved.
+ * @param array $types Optional. Restrict comment counts to one or more specific types.
+ *
  * @return array() {
  *     The number of comments keyed by their status.
  *
@@ -377,22 +380,62 @@ function get_lastcommentmodified( $timezone = 'server' ) {
  *     @type int        $all                 The total number of pending or approved comments.
  * }
  */
-function get_comment_count( $post_id = 0 ) {
+function get_comment_count( $post_id = 0, $types = array() ) {
 	global $wpdb;
 
 	$post_id = (int) $post_id;
 
-	$where = '';
+	$sql_select   = array( 'comment_approved', 'COUNT( * ) AS total' );
+	$select       = '';
+	$sql_where    = array();
+	$where        = '';
+	$sql_group_by = array( 'comment_approved' );
+	$group_by     = '';
+	$in_types     = array();
+
 	if ( $post_id > 0 ) {
-		$where = $wpdb->prepare( 'WHERE comment_post_ID = %d', $post_id );
+		$sql_where[] = $wpdb->prepare( 'comment_post_ID = %d', $post_id );
+	}
+
+	if ( ! is_array( $types ) ) {
+		$types = (array) $types;
+	}
+
+	if ( $types ) {
+		$in_types = array_intersect( $types, get_feedback_types() );
+
+		if ( $in_types ) {
+			if ( 1 < count( $in_types ) ) {
+				array_unshift( $sql_select, 'comment_type AS type' );
+				$sql_group_by[] = 'comment_type';
+			}
+
+			// Add compat type `''` used for comments.
+			if ( in_array( 'comment', $in_types, true ) ) {
+				$in_types[] = '';
+			}
+
+			$sql_where[] = sprintf( 'comment_type IN ( "%s" )', implode( '", "', array_map( 'sanitize_key', $in_types ) ) );
+
+			// Remove compat type `''` used for comments.
+			$types = array_filter( $in_types );
+		}
+	}
+
+	$select = implode( ', ', $sql_select );
+
+	if ( $sql_where ) {
+		$where = 'WHERE ' . implode( ' AND ', $sql_where );
 	}
 
+	$group_by = implode( ', ', $sql_group_by );
+
 	$totals = (array) $wpdb->get_results(
 		"
-		SELECT comment_approved, COUNT( * ) AS total
+		SELECT {$select}
 		FROM {$wpdb->comments}
 		{$where}
-		GROUP BY comment_approved
+		GROUP BY {$group_by}
 	",
 		ARRAY_A
 	);
@@ -407,34 +450,59 @@ function get_comment_count( $post_id = 0 ) {
 		'all'                 => 0,
 	);
 
+	if ( $types ) {
+		$comment_types_count = array_fill_keys( $types, $comment_count );
+
+		if ( 1 === count( $types ) ) {
+			$type = reset( $types );
+		}
+	} else {
+		$type                = 'any';
+		$comment_types_count = array(
+			$type => $comment_count,
+		);
+	}
+
 	foreach ( $totals as $row ) {
+		if ( isset( $row['type'] ) ) {
+			$type = $row['type'];
+
+			if ( '' === $type ) {
+				$type = 'comment';
+			}
+		}
+
 		switch ( $row['comment_approved'] ) {
 			case 'trash':
-				$comment_count['trash'] = $row['total'];
+				$comment_types_count[ $type ]['trash'] = $row['total'];
 				break;
 			case 'post-trashed':
-				$comment_count['post-trashed'] = $row['total'];
+				$comment_types_count[ $type ]['post-trashed'] = $row['total'];
 				break;
 			case 'spam':
-				$comment_count['spam']            = $row['total'];
-				$comment_count['total_comments'] += $row['total'];
+				$comment_types_count[ $type ]['spam']            = $row['total'];
+				$comment_types_count[ $type ]['total_comments'] += $row['total'];
 				break;
 			case '1':
-				$comment_count['approved']        = $row['total'];
-				$comment_count['total_comments'] += $row['total'];
-				$comment_count['all']            += $row['total'];
+				$comment_types_count[ $type ]['approved']        = $row['total'];
+				$comment_types_count[ $type ]['total_comments'] += $row['total'];
+				$comment_types_count[ $type ]['all']            += $row['total'];
 				break;
 			case '0':
-				$comment_count['awaiting_moderation'] = $row['total'];
-				$comment_count['total_comments']     += $row['total'];
-				$comment_count['all']                += $row['total'];
+				$comment_types_count[ $type ]['awaiting_moderation'] = $row['total'];
+				$comment_types_count[ $type ]['total_comments']     += $row['total'];
+				$comment_types_count[ $type ]['all']                += $row['total'];
 				break;
 			default:
 				break;
 		}
 	}
 
-	return $comment_count;
+	if ( 3 !== count( $sql_select ) ) {
+		$comment_types_count = reset( $comment_types_count );
+	}
+
+	return $comment_types_count;
 }
 
 //
@@ -1315,9 +1383,12 @@ function wp_blacklist_check( $author, $email, $url, $comment, $user_ip, $user_ag
  * @see get_comment_count() Which handles fetching the live comment counts.
  *
  * @since 2.5.0
+ * @since 5.4.0 Adds the $type parameter.
  *
  * @param int $post_id Optional. Restrict the comment counts to the given post. Default 0, which indicates that
  *                     comment counts for the whole site will be retrieved.
+ * @param string $type Optional. Restrict comment counts to a specific type.
+ *
  * @return stdClass {
  *     The number of comments keyed by their status.
  *
@@ -1330,33 +1401,40 @@ function wp_blacklist_check( $author, $email, $url, $comment, $user_ip, $user_ag
  *     @type int        $all            The total number of pending or approved comments.
  * }
  */
-function wp_count_comments( $post_id = 0 ) {
+function wp_count_comments( $post_id = 0, $type = '' ) {
 	$post_id = (int) $post_id;
 
 	/**
 	 * Filters the comments count for a given post or the whole site.
 	 *
 	 * @since 2.7.0
+	 * @since 5.4.0 Adds the $type parameter.
 	 *
 	 * @param array|stdClass $count   An empty array or an object containing comment counts.
 	 * @param int            $post_id The post ID. Can be 0 to represent the whole site.
+	 * @param string         $type    The comment type. Empty string for all types.
 	 */
-	$filtered = apply_filters( 'wp_count_comments', array(), $post_id );
+	$filtered = apply_filters( 'wp_count_comments', array(), $post_id, $type );
 	if ( ! empty( $filtered ) ) {
 		return $filtered;
 	}
 
-	$count = wp_cache_get( "comments-{$post_id}", 'counts' );
+	$cache_suffix = $post_id;
+	if ( $type && in_array( $type, get_feedback_types(), true ) ) {
+		$cache_suffix .= '-' . $type;
+	}
+
+	$count = wp_cache_get( "comments-{$cache_suffix}", 'counts' );
 	if ( false !== $count ) {
 		return $count;
 	}
 
-	$stats              = get_comment_count( $post_id );
+	$stats              = get_comment_count( $post_id, $type );
 	$stats['moderated'] = $stats['awaiting_moderation'];
 	unset( $stats['awaiting_moderation'] );
 
 	$stats_object = (object) $stats;
-	wp_cache_set( "comments-{$post_id}", $stats_object, 'counts' );
+	wp_cache_set( "comments-{$cache_suffix}", $stats_object, 'counts' );
 
 	return $stats_object;
 }
diff --git src/wp-includes/default-filters.php src/wp-includes/default-filters.php
index 9a46d7e2f7..fe18ec82d9 100644
--- src/wp-includes/default-filters.php
+++ src/wp-includes/default-filters.php
@@ -585,4 +585,7 @@ add_filter( 'user_has_cap', 'wp_maybe_grant_install_languages_cap', 1 );
 add_filter( 'user_has_cap', 'wp_maybe_grant_resume_extensions_caps', 1 );
 add_filter( 'user_has_cap', 'wp_maybe_grant_site_health_caps', 1, 4 );
 
+// Feedbacks.
+add_action( 'init', 'create_initial_feedback_types', 0 ); // highest priority
+
 unset( $filter, $action );
diff --git src/wp-includes/feedback.php src/wp-includes/feedback.php
new file mode 100644
index 0000000000..016a08337e
--- /dev/null
+++ src/wp-includes/feedback.php
@@ -0,0 +1,235 @@
+<?php
+/**
+ * Core Feedback API
+ *
+ * @package WordPress
+ * @subpackage Feedback
+ * @since 5.4.0
+ */
+
+/**
+ * Registers a feedback type.
+ *
+ * @since 5.4.0
+ *
+ * @param string $feedback_type Feedback type key. Must not exceed 20 characters and may
+ *                              only contain lowercase alphanumeric characters, dashes,
+ *                              and underscores. See `sanitize_key()`.
+ * @param array $args {
+ *     Array or string of arguments for registering a feedback type.
+ * }
+ * @return WP_Feedback_Type|WP_Error The registered feedback type object on success,
+ *                                   WP_Error object on failure.
+ */
+function register_feedback_type( $feedback_type, $args = array() ) {
+	global $wp_feedback_types;
+
+	if ( ! is_array( $wp_feedback_types ) ) {
+		$wp_feedback_types = array();
+	}
+
+	// Sanitize post type name
+	$feedback_type = sanitize_key( $feedback_type );
+
+	if ( empty( $feedback_type ) || strlen( $feedback_type ) > 20 ) {
+		_doing_it_wrong( __FUNCTION__, __( 'Feedback type names must be between 1 and 20 characters in length.' ), '5.4.0' );
+		return new WP_Error( 'feedback_type_length_invalid', __( 'Feedback type names must be between 1 and 20 characters in length.' ) );
+	}
+
+	$feedback_type_object                = new WP_Feedback_Type( $feedback_type, $args );
+	$wp_feedback_types[ $feedback_type ] = $feedback_type_object;
+
+	/**
+	 * Fires after a feedback type is registered.
+	 *
+	 * @since 5.4.0
+	 *
+	 * @param string           $feedback_type        Feedback type.
+	 * @param WP_Feedback_Type $feedback_type_object Arguments used to register the feedback type.
+	 */
+	do_action( 'registered_feedback_type', $feedback_type, $feedback_type_object );
+
+	return $feedback_type_object;
+}
+
+/**
+ * Creates the initial feedback types when 'init' action is fired.
+ *
+ * See {@see 'init'}.
+ *
+ * @since 5.4.0
+ */
+function create_initial_feedback_types() {
+	register_feedback_type(
+		'comment',
+		array(
+			'label'                 => __( 'Comments' ),
+			'labels'                => array(
+				'singular_name'  => _x( 'Comment', 'Feedback singular name' ),
+				'name_admin_nav' => _x( 'Comments', 'Feedback screen main nav' ),
+			),
+			'public'                => true,
+			'_builtin'              => true, /* internal use only. don't use this when registering your own feedback type. */
+			'_edit_link'            => 'comment.php?comment=%d', /* internal use only. don't use this when registering your own feedback type. */
+			'nav_position'          => 0,
+			'delete_with_user'      => false,
+			'supports'              => array( 'editor' ),
+			'show_in_rest'          => true,
+			'rest_base'             => 'comments',
+			'rest_controller_class' => 'WP_REST_Comments_Controller',
+		)
+	);
+
+	register_feedback_type(
+		'pingback',
+		array(
+			'label'                 => __( 'Pings' ),
+			'labels'                => array(
+				'singular_name'  => _x( 'Ping', 'Feedback singular name' ),
+				'name_admin_nav' => _x( 'Pings', 'Feedback screen main nav' ),
+			),
+			'public'                => true,
+			'_builtin'              => true, /* internal use only. don't use this when registering your own feedback type. */
+			'_edit_link'            => 'comment.php?comment=%d', /* internal use only. don't use this when registering your own feedback type. */
+			'nav_position'          => 1,
+			'delete_with_user'      => false,
+			'supports'              => array(),
+			'show_in_rest'          => true,
+			'rest_base'             => 'comments',
+			'rest_controller_class' => 'WP_REST_Comments_Controller',
+		)
+	);
+
+	register_feedback_type(
+		'trackback',
+		array(
+			'label'                 => __( 'Trackbacks' ),
+			'labels'                => array(
+				'singular_name'  => _x( 'Trackback', 'Feedback singular name' ),
+				'name_admin_nav' => _x( 'Trackbacks', 'Feedback screen main nav' ),
+			),
+			'public'                => true,
+			'_builtin'              => true, /* internal use only. don't use this when registering your own feedback type. */
+			'_edit_link'            => 'comment.php?comment=%d', /* internal use only. don't use this when registering your own feedback type. */
+			'nav_position'          => 2,
+			'delete_with_user'      => false,
+			'supports'              => array(),
+			'show_in_rest'          => true,
+			'rest_base'             => 'comments',
+			'rest_controller_class' => 'WP_REST_Comments_Controller',
+		)
+	);
+}
+
+function get_feedback_type_object( $feedback_type ) {
+	global $wp_feedback_types;
+
+	if ( ! is_scalar( $feedback_type ) || empty( $wp_feedback_types[ $feedback_type ] ) ) {
+		return null;
+	}
+
+	return $wp_feedback_types[ $feedback_type ];
+}
+
+function get_feedback_type_labels( $feedback_type_object ) {
+	$labels = (object) wp_parse_args( $feedback_type_object->labels, array() );
+
+	if ( ! isset( $labels->name ) ) {
+		$labels->name = $feedback_type_object->name;
+	}
+
+	if ( ! isset( $labels->name_admin_nav ) ) {
+		$labels->name_admin_nav = $feedback_type_object->name;
+	}
+
+	if ( ! isset( $labels->awaiting_mod_item ) ) {
+		/* translators: %s: Singular for the number of feedbacks awaiting moderation. */
+		$labels->awaiting_mod_item = _x( '%s Feedback in moderation', 'Feedback Administration screen navigation' );
+	}
+
+	if ( ! isset( $labels->awaiting_mod_items ) ) {
+		/* translators: %s: Plural for the number of feedbacks awaiting moderation. */
+		$labels->awaiting_mod_items = _x( '%s Feedbacks in moderation', 'Feedback Administration screen navigation' );
+	}
+
+	return $labels;
+}
+
+function feedback_type_exists( $feedback_type ) {
+	return (bool) get_feedback_type_object( $feedback_type );
+}
+
+function get_feedback_types( $args = array(), $output = 'names', $operator = 'and' ) {
+	global $wp_feedback_types;
+
+	$field = false;
+	if ( 'names' === $output ) {
+		$field = 'name';
+	}
+
+	return wp_filter_object_list( $wp_feedback_types, $args, $operator, $field );
+}
+
+/**
+ * Retrieves the total feedback counts for the given types.
+ *
+ * @since 5.4.0
+ *
+ * @param array $types The list of types needed to be counted.
+ * @return array       An associative array of the count objects keyed according to their type.
+ */
+function wp_count_feedbacks( $types = array() ) {
+	if ( ! $types ) {
+		$types = get_feedback_types();
+	}
+
+	$counts = array();
+
+	/**
+	 * Filters the feedback counts for the given types.
+	 *
+	 * @since 5.4.0
+	 *
+	 * @param array $counts An empty array or the array containing feedback counts.
+	 * @param array $types  The list of feedback type's names.
+	 */
+	$filtered = apply_filters( 'wp_count_feedbacks', $counts, $types );
+	if ( ! empty( $filtered ) ) {
+		return $filtered;
+	}
+
+	// Used to store the types to count.
+	$to_count = array();
+
+	// Try to get the count from cache.
+	foreach ( $types as $name ) {
+		$counts[ $name ] = wp_cache_get( "comments-0-{$name}", 'counts' );
+
+		if ( ! $counts[ $name ] ) {
+			$to_count[] = $name;
+		}
+	}
+
+	// If some counts are not available perform the count.
+	if ( $to_count ) {
+		$uncache_counts = array();
+		$feedbacks      = get_comment_count( 0, $to_count );
+
+		if ( 1 === count( $to_count ) ) {
+			$type                    = reset( $to_count );
+			$uncache_counts[ $type ] = $feedbacks;
+		} else {
+			$uncache_counts = $feedbacks;
+		}
+
+		foreach ( $uncache_counts as $t => $count ) {
+			$count['moderated'] = $count['awaiting_moderation'];
+			unset( $count['awaiting_moderation'] );
+
+			$counts[ $t ] = (object) $count;
+			wp_cache_set( "comments-0-{$t}", $counts[ $t ], 'counts' );
+		}
+	}
+
+	return $counts;
+}
diff --git src/wp-includes/script-loader.php src/wp-includes/script-loader.php
index 8f9ec7b428..de3a8f1f1b 100644
--- src/wp-includes/script-loader.php
+++ src/wp-includes/script-loader.php
@@ -1685,6 +1685,7 @@ function wp_default_styles( $styles ) {
 	$styles->add( 'l10n', "/wp-admin/css/l10n$suffix.css" );
 	$styles->add( 'code-editor', "/wp-admin/css/code-editor$suffix.css", array( 'wp-codemirror' ) );
 	$styles->add( 'site-health', "/wp-admin/css/site-health$suffix.css" );
+	$styles->add( 'feedbacks', "/wp-admin/css/feedbacks$suffix.css" );
 
 	$styles->add( 'wp-admin', false, array( 'dashicons', 'common', 'forms', 'admin-menu', 'dashboard', 'list-tables', 'edit', 'revisions', 'media', 'themes', 'about', 'nav-menus', 'widgets', 'site-icon', 'l10n' ) );
 
diff --git src/wp-settings.php src/wp-settings.php
index a7b9251e88..084efcb6f0 100644
--- src/wp-settings.php
+++ src/wp-settings.php
@@ -195,6 +195,8 @@ require ABSPATH . WPINC . '/category.php';
 require ABSPATH . WPINC . '/class-walker-category.php';
 require ABSPATH . WPINC . '/class-walker-category-dropdown.php';
 require ABSPATH . WPINC . '/category-template.php';
+require ABSPATH . WPINC . '/feedback.php';
+require ABSPATH . WPINC . '/class-wp-feedback-type.php';
 require ABSPATH . WPINC . '/comment.php';
 require ABSPATH . WPINC . '/class-wp-comment.php';
 require ABSPATH . WPINC . '/class-wp-comment-query.php';
